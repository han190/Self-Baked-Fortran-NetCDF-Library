#: include "module_common.fypp"
submodule(module_interface) submodule_attribute
implicit none
contains

#: for nc_type, type, kind in zip(nc_types, types, kinds)
!> ${type}$(${kind}$) attribute constructor
module pure function new_att_vec_${kind}$(name, vals) result(att)
  character(*), intent(in) :: name
  ${type}$(${kind}$), intent(in) :: vals(:)
  type(attribute_${kind}$_type) :: tmp
  type(attribute_type) :: att

  tmp%len = size(vals)
  tmp%name = name
  tmp%type = ${nc_type}$
  tmp%vals = vals
  att%att = tmp
end function new_att_vec_${kind}$ ${"\n"}$
#: endfor

#: for nc_type, type, kind in zip(nc_types, types, kinds)
!> ${type}$(${kind}$) attribute constructor
module pure function new_att_scal_${kind}$(name, val) result(att)
  character(*), intent(in) :: name
  ${type}$(${kind}$), intent(in) :: val
  type(attribute_${kind}$_type) :: tmp
  type(attribute_type) :: att

  tmp%len = 1
  tmp%name = name
  tmp%type = ${nc_type}$
  tmp%vals = [val]
  att%att = tmp
end function new_att_scal_${kind}$ ${"\n"}$
#: endfor

module pure function new_att_scal_char(name, val) result(att)
  character(len=*), intent(in) :: name, val
  type(attribute_char_type) :: tmp
  type(attribute_type) :: att

  tmp%len = len(val)
  tmp%name = name
  tmp%type = nc_char
  tmp%vals = [val]
  att%att = tmp
end function new_att_scal_char

module function new_atts(atts) result(ret)
  type(attribute_type), intent(in) :: atts(:)
  type(attribute_type), allocatable :: ret(:)
  integer :: i

  ret = atts
  do i = 1, size(ret)
    ret(i)%att%ID = i - 1
  end do
end function new_atts

end submodule submodule_attribute