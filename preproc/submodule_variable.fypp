#: include "module_common.fypp"
submodule(module_interface) submodule_variable
implicit none
contains

#: for rank in range(num_ranks)
#: set cols = (":," + "".join([":," for _ in range(rank)]))[:-1]
#: for nc_type, type, kind in zip(nc_types, types, kinds)
!> variable constructor for ${type}$(${kind}$), rank(${rank}$)
module function new_variable_${kind}$_${rank + 1}$d( &
  & data, name, dims, atts) result(var)
  ${type}$(${kind}$), target, contiguous, intent(in) :: data(${cols}$)
  character(len=*), intent(in) :: name
  type(dimension_type), intent(in) :: dims(:)
  type(attribute_type), intent(in) :: atts(:)
  type(variable_type) :: var
  type(variable_${kind}$_type) :: tmp
  ${type}$(${kind}$), pointer :: ptr(:) => null()

  ptr(1:size(data)) => data
  allocate(tmp%vals, source=ptr)
  tmp%name = name
  tmp%dims = dims
  tmp%atts = atts
  tmp%type = ${nc_type}$
  var%var = tmp
  nullify (ptr)
end function new_variable_${kind}$_${rank + 1}$d ${"\n"}$

!> variable constructor for ${type}$(${kind}$), rank(${rank}$)
module function new_variable_noatt_${kind}$_${rank + 1}$d( &
  & data, name, dims) result(var)
  ${type}$(${kind}$), target, contiguous, intent(in) :: data(${cols}$)
  character(len=*), intent(in) :: name
  type(dimension_type), intent(in) :: dims(:)
  type(variable_type) :: var
  type(variable_${kind}$_type) :: tmp
  ${type}$(${kind}$), pointer :: ptr(:) => null()

  ptr(1:size(data)) => data
  allocate(tmp%vals, source=ptr)
  tmp%name = name
  tmp%dims = dims
  tmp%type = ${nc_type}$
  var%var = tmp
  nullify (ptr)
end function new_variable_noatt_${kind}$_${rank + 1}$d ${"\n"}$
#: endfor
#: endfor
#: del cols

!> Shape of variable
module pure function shape_var(var) result(ret)
  type(variable_type), intent(in) :: var
  integer, allocatable :: ret(:)

  ret = shape_dims(var%var%dims)
end function shape_var

!> Define variable
subroutine def_var(var)
  type(variable_type), intent(inout) :: var
  integer(c_int) :: stat, ndims, i
  integer(c_int), allocatable :: dimids(:)

  select type (var_ => var%var)
  #: for c_name, kind in zip(c_names[1:], kinds[1:])
  type is (variable_${kind}$_type)

    ndims = size(var_%dims, kind=c_int)
    dimids = [(var_%dims(i)%ID, i=1, ndims)]
    stat = nc_def_var(var_%grpID, cstr(var_%name), &
      & var_%type, ndims, dimids, var_%ID)
    call handle_error(stat, "nc_def_var")
  
  #: endfor
  end select
end subroutine def_var

!> Put variable
subroutine put_var(var)
  type(variable_type), intent(in) :: var
  integer(c_int) :: stat

  select type (var_ => var%var)
  #: for c_name, kind in zip(c_names[1:], kinds[1:])
  type is (variable_${kind}$_type)

    stat = nc_put_var_${c_name}$( &
      & var_%grpID, var_%ID, var_%vals)
    call handle_error(stat, "nc_put_var_${c_name}$")

  #: endfor
  end select
end subroutine put_var

!> Write variable to a netcdf file
module subroutine to_netcdf_var(var, filename)
  type(variable_type), intent(inout) :: var
  character(len=*), intent(in) :: filename
  type(file_type), target :: file
  integer(c_int) :: stat

  !> copy metadata
  file%filename = filename
  file%mode = ior(nc_netcdf4, nc_clobber)

  !> create
  stat = nc_create(cstr(filename), file%mode, file%ID)
  call handle_error(stat, "nc_create")
  var%var%grpID => file%ID

  !> rootgroup name
  file%name = cstr("/")

  !> Define dimension
  call def_var_dim(var)

  !> Put group attributes
  if (allocated(file%atts)) then
    call put_grp_atts(file)
  end if

  !> Put variable attributes
  call def_var(var)
  if (allocated(var%var%atts)) then
    call put_var_atts(var)
  end if
  call put_var(var)
  nullify (var%var%grpID)

  stat = nc_close(file%ID)
  call handle_error(stat, "nc_close")
end subroutine to_netcdf_var

end submodule submodule_variable