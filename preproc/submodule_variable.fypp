#: include "module_common.fypp"
submodule(module_fortran_interface) submodule_variable
implicit none
contains

module function data_array(data, name, dims, atts) result(var)
  class(*), intent(in) :: data(:)
  character(len=*), intent(in) :: name
  type(nc_dim), intent(in) :: dims(:)
  type(nc_att), intent(in), optional :: atts(:)
  type(nc_var) :: var

  var%name = name
  var%dims = dims
  if (present(atts)) var%atts = atts
  ! if (allocated(var%vals)) deallocate (var%vals)
  ! allocate (var%vals, source=data)
  var%vals = data

  select type (data)
  #: for type, kind, nc_type in zip(types, kinds, nc_types)
  type is (${type}$(${kind}$))
    var%type = ${nc_type}$
  #: endfor
  type is (character(*))
    var%type = nc_char
  end select
end function data_array

module pure function shape_var(var) result(ret)
  type(nc_var), intent(in) :: var
  integer, allocatable :: ret(:)

  ret = shape_dims(var%dims)
end function shape_var

subroutine def_var(var)
  type(nc_var), intent(inout) :: var
  integer(c_int) :: stat, ndims, i
  integer(c_int), allocatable :: dimids(:)

  ndims = size(var%dims, kind=c_int)
  dimids = [(var%dims(i)%ID, i=1, ndims)]
  if (associated(var%grpID)) then
    stat = nc_def_var(var%grpID, cstr(var%name), &
      & var%type, ndims, dimids, var%ID)
    call handle_error(stat, "nc_def_var")
  else
    error stop "Group ID not associated."
  end if
end subroutine def_var

subroutine put_var(var)
  type(nc_var), intent(in) :: var
  integer(c_int) :: stat

  if (.not. allocated(var%vals)) &
    & error stop "[put_var] Varible values not allocated."

  select type (vals_ => var%vals)
  #: for type, kind, c_name in zip(types, kinds, c_names)
  type is (${type}$(${kind}$))
    stat = nc_put_var_${c_name}$(var%grpID, var%ID, vals_)
    call handle_error(stat, "nc_put_var_${c_name}$")
  #: endfor
  end select
end subroutine put_var

module function inq_var(grp, name) result(var)
  class(nc_grp), target, intent(inout) :: grp
  character(len=*), intent(in) :: name
  type(nc_var) :: var
  integer(c_int) :: stat

  var%grpID => grp%ID
  var%name = name
  stat = nc_inq_varid(var%grpID, cstr(name), var%ID)
  call handle_error(stat, "nc_inq_varid")

  stat = nc_inq_vartype(var%grpID, var%ID, var%type)
  call handle_error(stat, "nc_inq_vartype")

  call inq_var_dims(var)
  call inq_var_atts(var)
  call get_var_atts(var)
end function inq_var

subroutine get_var(var)
  type(nc_var), intent(inout) :: var
  integer(c_int) :: stat, total_len

  if (.not. associated(var%grpID)) &
    & error stop "[get_var] Group ID not associated."

  if (allocated(var%vals)) deallocate (var%vals)
  total_len = product(shape(var))

  select case (var%type)
  #: for type, kind, nc_type in zip(types, kinds, nc_types)
  case (${nc_type}$)
    allocate (${type}$(${kind}$) :: var%vals(total_len))
  #: endfor
  end select

  select type (vals_ => var%vals)
  #: for kind, type, c_name in zip(kinds, types, c_names)
  type is (${type}$(${kind}$))
    stat = nc_get_var_${c_name}$(var%grpID, var%ID, vals_)
    call handle_error(stat, "nc_get_var_${c_name}$")
  #: endfor
  end select
end subroutine get_var

module subroutine to_netcdf_var(var, filename, mode)
  type(nc_var), intent(inout) :: var
  character(len=*), intent(in) :: filename
  integer(c_int), intent(in), optional :: mode
  type(nc_file), target :: file
  integer(c_int) :: stat

  !> Copy metadata
  file%filename = filename
  file%name = cstr("/")

  if (present(mode)) then
    file%mode = mode
  else
    file%mode = ior(nc_netcdf4, nc_clobber)
  end if

  select case (file%mode)
  case (ior(nc_netcdf4, nc_clobber))
    stat = nc_create(cstr(filename), file%mode, file%ID)
    call handle_error(stat, "nc_create")
    var%grpID => file%ID

    call def_var_dim(var)
    call def_var(var)

    if (allocated(file%atts)) call put_grp_atts(file)
    if (allocated(var%atts)) call put_var_atts(var)

    ! enddef is not required for netcdf4
    ! stat = nc_enddef(file%ID)
    ! call handle_error(stat, "nc_enddef")

    call put_var(var)
    nullify (var%grpID)
  case default
    error stop "Mode not supported yet."
  end select

  stat = nc_close(file%ID)
  call handle_error(stat, "nc_close")
end subroutine to_netcdf_var

module function from_netcdf_var(filename, name) result(var)
  character(len=*), intent(in) :: filename, name
  type(nc_var) :: var
  type(nc_file) :: file
  integer(c_int) :: stat
  character(kind=c_char, len=nc_max_name) :: tmp

  file%filename = filename
  file%mode = nc_nowrite

  stat = nc_open(cstr(file%filename), file%mode, file%ID)
  call handle_error(stat, "nc_open")
  var = inq_var(file, name)
  call get_var(var)
end function from_netcdf_var

end submodule submodule_variable
