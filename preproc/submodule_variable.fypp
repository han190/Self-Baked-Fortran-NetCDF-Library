#:include "module_common.fypp"
submodule(module_netcdf) submodule_variable

implicit none
contains

!> Get meta data for a variable
module function get_var(group, name) result(variable)
  type(group_type), intent(inout) :: group
  character(*), intent(in) :: name
  type(variable_type) :: variable
  integer :: status

  !> Inquire variable ID
  variable%name = name
  status = nc_inq_varid(group%id, name//c_null_char, variable%id)
  call handle_error(status, "nc_inq_varid")

  !> Inquire dimensions and attributes
  call inquire_dimensions(group, variable)
  call inquire_attributes(group, variable)

  !> Inquire variable type
  status = nc_inq_vartype(group%id, variable%id, variable%type)
  call handle_error(status, "nc_inq_vartype")

  !> Get variable
  call get_var_(group, variable)
end function get_var

!> Based on the rank and type of the data, get the variable.
subroutine get_var_(group, variable)
  type(group_type), intent(inout) :: group
  type(variable_type), intent(inout) :: variable
  integer(c_int) :: status

  if (.not. associated(variable%dimensions)) &
    error stop "Dimensions not associated."

  !> Select rank.
  select case (size(variable%dimensions))
  #: for rank in ranks
  case (${rank}$)
    allocate (container_${rank}$d :: variable%container)
  #: endfor
  case default
    error stop "Invalid data rank."
  end select

  !> Select type
  select case (variable%type)
  #:for nc_kind, kind, get_var in zip(nc_kinds, kinds, get_vars)
  case (${nc_kind}$)

    select type (container_ => variable%container)
    #:for rank in ranks
    type is (container_${rank}$d)

      associate (s => shape(variable%dimensions))
      #: set shp = ", ".join(["s({})".format(i + 1) for i in range(int(rank))])
        allocate (${kind}$ :: container_%data(${shp}$))
      end associate
      select type (data_ => container_%data)
      type is (${kind}$)
        status = ${get_var}$ (group%id, variable%id, data_)
        call handle_error(status, "${get_var}$")
      end select

    #:endfor
    end select

  #:endfor
  end select
end subroutine get_var_

!> Shape of a variable
module function shape_variable(variable) result(shapes)
  type(variable_type), intent(in) :: variable
  integer(int64), allocatable :: shapes(:)

  if (allocated(shapes)) deallocate (shapes)
  if (.not. associated(variable%dimensions)) &
    error stop "Variable dimensions not associated."
  shapes = shape_dimensions(variable%dimensions)
end function shape_variable

end submodule submodule_variable
